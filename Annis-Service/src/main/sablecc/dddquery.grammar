Package de.deutschdiachrondigital.dddquery;


Helpers
	blank = ' ' | 10 | 13;
	
	digit = [ '0' .. '9' ];
	alpha = [ 'a' .. 'z' ] | [ 'A' .. 'Z' ] | 'ä' | 'Ä' | 'ö' | 'Ö' | 'ü' | 'ü' | 'ß';
	pattern = [ [ 0x0000 .. 0xffff ] - '"' ];
	
	wildcard = '?' | '*' | '_';
	
	quote = '"' | ''';

States
	default, pattern;
	

Tokens
	{default -> pattern} l_quote = quote;
	{default -> pattern} l_wild_quote = 'm' quote;
	{default -> pattern} l_regexp_quote = 'r' quote;
	{pattern} pattern = pattern+;
	{pattern -> default} r_quote = quote;

	{default} blanks = blank+;
	
	{default} dot = '.';
	{default} slash = '/';
	
	{default} axis_delim = '::';
	
	{default} lpar = '(';
	{default} rpar = ')';
	{default} lbracket = '[';
	{default} rbracket = ']';
	
	{default} hash = '#';
	{default} hash_plus = '#+';
	{default} hash_minus = '#-';
	
	{default} dollar = '$';
	
	{default} comma = ',';
	
	{default} colon = ':';

	// Abkürzungen
	{default} abbr_parent = '\';
	{default} abbr_ancestor = '\\';
	{default} abbr_sibling = '^';
	{default} abbr_following = '-->';
	{default} abbr_preceding = '<--';
	{default} abbr_following_sibling = '-->^';
	{default} abbr_preceding_sibling = '<--^';
	{default} abbr_immediately_following_sibling = '->^';
	{default} abbr_immediately_preceding_sibling = '<-^';
	{default} abbr_immediately_following = '->';
	{default} abbr_immediately_preceding = '<-';
	{default} abbr_contained = '~>';
	{default} abbr_containing = '~<';
	{default} abbr_attribute = '/@';
	{default} abbr_attribute_predicate = '@';
	{default} abbr_parent_nodes = '..';

	// Vertikale Navigation	
	{default} axis_child = 'child';
	{default} axis_left_child = 'left-child';
	{default} axis_right_child = 'right-child';
	{default} axis_parent = 'parent';
	{default} axis_descendant = 'descendant';
	{default} axis_ancestor = 'ancestor';
	{default} axis_sibling = 'sibling';
	{default} axis_common_ancestor = 'common-ancestor';

	// Horizontale Navigation
	{default} axis_following = 'following';
	{default} axis_preceding = 'preceding';
	{default} axis_following_sibling = 'following-sibling';
	{default} axis_preceding_sibling = 'preceding-sibling';
	{default} axis_immediately_following_sibling = 'immediately-following-sibling';
	{default} axis_immediately_preceding_sibling = 'immediately-preceding-sibling';
	
	// Span-Relationen
	{default} axis_immediately_following = 'immediately-following';
	{default} axis_immediately_preceding = 'immediately-preceding';
	{default} axis_contained = 'contained';
	{default} axis_containing = 'containing';
	{default} axis_prefix = 'prefix';
	{default} axis_suffix = 'suffix';
	{default} axis_overlapping = 'overlapping';
	{default} axis_overlapping_following = 'overlapping-following';
	{default} axis_overlapping_preceding = 'overlapping-preceding';
	{default} axis_whole_text = 'whole-text';
	
	// Navigation von einem Knotentyp zum anderen
	{default} axis_element_span = 'element-span';
	{default} axis_layer = 'layer';
	{default} axis_alignment = 'alignment';
	{default} axis_aligned = 'aligned';
	{default} axis_matching_element = 'matching-element';
	{default} axis_contained_element = 'contained-element';
	{default} axis_containing_element = 'containing-element';
	
	// neue Achsen
	{default} axis_left_align = 'left-align';
	{default} axis_right_align = 'right-align';
	
	// Knotentests
	{default} type_element = 'element';
	{default} type_span = 'span';
	{default} meta = 'meta';
	
	// Textsuche
	{default} text_exact = 'exact-match';
	{default} text_wild = 'wild-match';
	{default} text_regexp = 're-match';

	// attribute kann sowohl Achse als auch Knotentest sein	
	{default} attribute = 'attribute';

	{default} or = '|';
	{default} and = '&';
	
	{default} eq = '=';
	{default} ne = '!=';
	{default} lt = '<';
	{default} le = '<=';
	{default} gt = '>';
	{default} ge = '>=';
	
	{default} plus = '+';
	{default} minus = '-';
	{default} times = '*';
	{default} div = 'div';
	{default} idiv = 'idiv';
	{default} mod = 'mod';
	
	{default} number = ('-' | '+')* digit+ ('.' digit+)? ( ('e' | 'E') ('-' | '+')? digit+)?;
	{default} id = (alpha | digit | wildcard | '-' | '_' | '.' )+;
	
Ignored Tokens
	blanks;
	

Productions

	expr { -> expr } = or_expr { -> or_expr.expr };

	or_expr { -> expr } =
	      and_expr { -> and_expr.expr }
		| {or} and_expr or_tail+ { -> New expr.or( [ and_expr.expr, or_tail.expr ] ) }
		;
		
	or_tail { -> expr } = or and_expr { -> and_expr.expr };
		
	and_expr { -> expr } =
		  comp_expr { -> comp_expr.expr }
		| {and} comp_expr and_tail+ { -> New expr.and( [ comp_expr.expr, and_tail.expr ] ) }
		;
		
	and_tail { -> expr } = and comp_expr { -> comp_expr.expr };
		
	comp_expr { -> expr } = 
		  add_expr { -> add_expr.expr }
		| {equals} [lhs]:add_expr eq [rhs]:add_expr { -> New expr.comparison(New comparison.eq(), lhs.expr, rhs.expr) }
		| {not_equals} [lhs]:add_expr ne [rhs]:add_expr { -> New expr.comparison(New comparison.ne(), lhs.expr, rhs.expr) }
		| {less_than} [lhs]:add_expr lt [rhs]:add_expr { -> New expr.comparison(New comparison.lt(), lhs.expr, rhs.expr) }
		| {less_or_equal} [lhs]:add_expr le [rhs]:add_expr { -> New expr.comparison(New comparison.le(), lhs.expr, rhs.expr) }
		| {greater_than} [lhs]:add_expr gt [rhs]:add_expr { -> New expr.comparison(New comparison.gt(), lhs.expr, rhs.expr) }
		| {greater_or_equal} [lhs]:add_expr ge [rhs]:add_expr { -> New expr.comparison(New comparison.ge(), lhs.expr, rhs.expr) }
		;
		
	add_expr { -> expr } =
	      mult_expr { -> mult_expr.expr }
		| {plus} [lhs]:add_expr plus [rhs]:mult_expr { -> New expr.plus(lhs.expr, rhs.expr) }
		| {minus} [lhs]:add_expr minus [rhs]:mult_expr { -> New expr.minus(lhs.expr, rhs.expr) }
		;

	mult_expr { -> expr } =
		  primary_expr { -> primary_expr.expr }
		| {times} [lhs]:mult_expr times [rhs]:primary_expr { -> New expr.times(lhs.expr, rhs.expr) }
		| {div} [lhs]:mult_expr div [rhs]:primary_expr { -> New expr.div(lhs.expr, rhs.expr) }
		| {idiv} [lhs]:mult_expr idiv [rhs]:primary_expr { -> New expr.idiv(lhs.expr, rhs.expr) }
		| {mod} [lhs]:mult_expr mod [rhs]:primary_expr { -> New expr.mod(lhs.expr, rhs.expr) }
		;
		
	primary_expr { -> expr } =
		  path { -> path.expr }
		| {grouped} lpar expr rpar { -> expr }
		| {number} number { -> New expr.number_literal(number) }
		| {function} id lpar function_args? rpar { -> New expr.function(id, [ function_args.expr ] ) }
		;
		
	function_args { -> expr* } = 
		  {last} expr { -> [ expr ] }
		| {list} expr comma function_args { -> [ expr, function_args.expr ] }
		;
		
	// 7.4.1 Pfadmuster
	path { -> expr } = 
		  {context} dot inner_step* { -> New expr.path( New path_type.relative(), [ inner_step.step ] ) }
		| {abbr_parent} abbr_parent_nodes inner_step* { -> New expr.path( New path_type.relative(), [ New step(New axis.parent(), New node_test.unknown(Null, Null), Null, [ ], Null), inner_step.step ] ) }
		| {relative} start_step inner_step* { -> New expr.path( New path_type.relative(), [ start_step.step, inner_step.step ] ) }
		| {absolute} slash start_step inner_step* { -> New expr.path( New path_type.absolute(), [ start_step.step, inner_step.step ] ) }
		
		// inline for "//a" to work around a reduce/reduce conflict
		| {descendant} [s1]:slash [s2]:slash node_test marker_spec? predicate* variable_binding? inner_step* { -> New expr.path( New path_type.absolute(), [
			New step(New axis.descendant(Null, Null), node_test, marker_spec, [ predicate.expr ], variable_binding.id ), inner_step.step 
		  ] ) }
		  
		// inline for "@a" to enable "/a[@b]" instead of "/a[/@b]"
		| {attribute} abbr_attribute_predicate node_test marker_spec? predicate* variable_binding? inner_step* { -> New expr.path( New path_type.relative(), [
			New step(New axis.attribute(), node_test, marker_spec, [ predicate.expr ], variable_binding.id ), inner_step.step 
		  ] ) }

		;

	start_step { -> step } =
		  {full} axis axis_delim node_test marker_spec? predicate* variable_binding? { -> New step(axis, node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_child} node_test marker_spec? predicate* variable_binding? { -> New step(Null, node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| step { -> step }
		;
		
	inner_step { -> step } =
		  {full} slash axis axis_delim node_test marker_spec? predicate* variable_binding? { -> New step(axis, node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }

		// 7.4.4 Achsen (Abkürzungen)
		| {abbr_child} slash node_test marker_spec? predicate* variable_binding? { -> New step(New axis.child(Null, [] ), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		
		// no abbreviation for // to work around a reduce/reduce conflict
		| {abbr_descendant} [s1]:slash [s2]:slash node_test marker_spec? predicate* variable_binding? { -> New step(New axis.descendant(Null, Null), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| step { -> step }
		;
		

	// 7.4.2 Schritte
	step { -> step } =
		  {abbr_parent} abbr_parent node_test marker_spec? predicate* variable_binding? { -> New step(New axis.parent(), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_ancestor} abbr_ancestor node_test marker_spec? predicate* variable_binding? { -> New step(New axis.ancestor(), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_sibling} abbr_sibling node_test marker_spec? predicate* variable_binding? { -> New step(New axis.sibling(Null, []), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_following} abbr_following node_test marker_spec? predicate* variable_binding? { -> New step(New axis.following(Null), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_preceding} abbr_preceding node_test marker_spec? predicate* variable_binding? { -> New step(New axis.preceding(), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_following_sibling} abbr_following_sibling node_test marker_spec? predicate* variable_binding? { -> New step(New axis.following_sibling(), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_preceding_sibling} abbr_preceding_sibling node_test marker_spec? predicate* variable_binding? { -> New step(New axis.preceding_sibling(), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_immediately_following_sibling} abbr_immediately_following_sibling node_test marker_spec? predicate* variable_binding? { -> New step(New axis.immediately_following_sibling(), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_immediately_preceding_sibling} abbr_immediately_preceding_sibling node_test marker_spec? predicate* variable_binding? { -> New step(New axis.immediately_preceding_sibling(), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_immediately_following} abbr_immediately_following node_test marker_spec? predicate* variable_binding? { -> New step(New axis.immediately_following(), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_immediately_preceding} abbr_immediately_preceding node_test marker_spec? predicate* variable_binding? { -> New step(New axis.immediately_preceding(), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_contained} abbr_contained node_test marker_spec? predicate* variable_binding? { -> New step(New axis.contained(), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_containing} abbr_containing node_test marker_spec? predicate* variable_binding? { -> New step(New axis.containing(), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_attribute} abbr_attribute node_test marker_spec? predicate* variable_binding? { -> New step(New axis.attribute(), node_test, marker_spec, [ predicate.expr ], variable_binding.id ) }
		| {abbr_parent_nodes} slash abbr_parent_nodes { -> New step(New axis.parent(), New node_test.unknown(Null, Null), Null, [ ], Null ) }
		;
	
	// 7.4.4 Achsen	
	axis { -> axis } =
		  {child} axis_child edge_type_spec? edge_spec? { -> New axis.child(edge_type_spec, [ edge_spec.edge_annotation ] ) }
		| {left_child} axis_left_child { -> New axis.left_child() }
		| {right_child} axis_right_child { -> New axis.right_child() }
		| {parent} axis_parent { -> New axis.parent() }
		| {descendant} axis_descendant edge_type_spec? range_spec? { -> New axis.descendant(edge_type_spec, range_spec) }
		| {ancestor} axis_ancestor { -> New axis.ancestor() }
		| {sibling} axis_sibling sibling_spec? edge_spec? { -> New axis.sibling(sibling_spec.edge_type_spec, [ edge_spec.edge_annotation ] ) }
		| {common_ancestor} axis_common_ancestor sibling_spec? { -> New axis.common_ancestor(sibling_spec.edge_type_spec) }
		| {following} axis_following range_spec? { -> New axis.following(range_spec) }
		| {preceding} axis_preceding { -> New axis.preceding() }
		| {following_sibling} axis_following_sibling { -> New axis.following_sibling() }
		| {preceding_sibling} axis_preceding_sibling { -> New axis.preceding_sibling() }
		| {immediately_following_sibling} axis_immediately_following_sibling { -> New axis.immediately_following_sibling() }
		| {immediately_preceding_sibling} axis_immediately_preceding_sibling { -> New axis.immediately_preceding_sibling() }
		| {immediately_following} axis_immediately_following { -> New axis.immediately_following() }
		| {immediately_preceding} axis_immediately_preceding { -> New axis.immediately_preceding() }
		| {contained} axis_contained { -> New axis.contained() }
		| {containing} axis_containing { -> New axis.containing() }
		| {prefix} axis_prefix { -> New axis.prefix() }
		| {suffix} axis_suffix { -> New axis.suffix() }
		| {overlapping} axis_overlapping { -> New axis.overlapping() }
		| {overlapping_following} axis_overlapping_following { -> New axis.overlapping_following() }
		| {overlapping_preceding} axis_overlapping_preceding { -> New axis.overlapping_preceding() }
		| {whole_text} axis_whole_text { -> New axis.whole_text() }
		| {element_span} axis_element_span { -> New axis.element_span() }		
		| {attribute} attribute { -> New axis.attribute() }
		| {layer} axis_layer lpar id rpar { -> New axis.layer(id) }
		| {alignment} axis_alignment lpar alignment_spec rpar { -> New axis.alignment(alignment_spec) }
		| {aligned} axis_aligned lpar alignment_spec rpar { -> New axis.aligned(alignment_spec) }
		| {matching_element} axis_matching_element { -> New axis.matching_element() }
		| {containing_element} axis_containing_element { -> New axis.containing_element() }
		| {contained_element} axis_contained_element { -> New axis.contained_element() }
		| {left_align} axis_left_align { -> New axis.left_align() }
		| {right_align} axis_right_align { -> New axis.right_align() }
		;
		
	range_spec { -> range_spec } =
	      {single} lpar [num]:number rpar { -> New range_spec(num, Null) }
	    | {range} lpar [min]:number comma [max]:number rpar { -> New range_spec(min, max) }
	    ;
		
	edge_spec { -> edge_annotation+ } = lpar edge_annotation+ rpar { -> [ edge_annotation ] } ;
		
	edge_annotation { -> edge_annotation } = 
		  {existance} namespace? [anno_type]:id { -> New edge_annotation.existance(namespace.id, anno_type) }
		| {exact} namespace? [anno_type]:id eq l_quote pattern r_quote { -> New edge_annotation.exact(namespace.id, anno_type, pattern) }
		| {regexp} namespace? [anno_type]:id eq l_regexp_quote pattern r_quote { -> New edge_annotation.regexp(namespace.id, anno_type, pattern) }
		;
		
	alignment_spec { -> alignment_spec } =
		  {full} [role1]:id [c1]:comma [role2]:id [c2]:comma [greed1]:id [c3]:comma [greed2]:id { -> New alignment_spec(role1, role2, greed1, greed2) }
		| {same_greed} [role1]:id [c1]:comma [role2]:id [c2]:comma [greed1]:id { -> New alignment_spec(role1, role2, greed1, Null) }
		| {no_greed} [role1]:id [c1]:comma [role2]:id { -> New alignment_spec(role1, role2, Null, Null) }
		;
		
	sibling_spec { -> edge_type_spec } =
		  {named} lbracket [name]:id rbracket { -> New edge_type_spec(Null, name) }
		;
		
	edge_type_spec { -> edge_type_spec } = 
		  lbracket [edge_type]:id rbracket { -> New edge_type_spec(edge_type, Null) }
		| {named} lbracket [edge_type]:id comma [name]:id rbracket { -> New edge_type_spec(edge_type, name) }
		;
		
	quoted_text { -> quoted_text } =
		  l_quote pattern r_quote { -> New quoted_text(pattern) }
		| {regexp} l_regexp_quote pattern r_quote { -> New quoted_text.regexp(pattern) }
		;	
	
	quote =
		  {normal} l_quote
		| {regexp} l_regexp_quote;
		
	node_test { -> node_test } = 
		  {element} type_element lpar [name]:id? rpar { -> New node_test.element(name) }
		| {any_element} type_element lpar times rpar { -> New node_test.element(Null) }
		| {attribute} attribute lpar namespace? [name]:id? rpar { -> New node_test.attribute(namespace.id, name) }
		| {any_attribute} attribute lpar times rpar { -> New node_test.attribute(Null, Null) }
		| {span} type_span lpar rpar { -> New node_test.span() }
		| {meta} meta lpar namespace? [name]:id eq quoted_text rpar { -> New node_test.meta(namespace.id, name, quoted_text) }
		| {unknown} namespace? [name]:id { -> New node_test.unknown(namespace.id, name) }
		// Workaround, da "*" (times) nicht als id gematcht wird
		| {any} times { -> New node_test.unknown(Null, Null) }
		
		| {exact_search} text_exact lpar l_quote pattern r_quote rpar { -> New node_test.exact_search(pattern) }

		// String-Literale können auf 2 versch. zum Start-Symbol zurückgeführt werden
		// Wenn weder Achse, Markierung, Prädikate noch Variablenbindung vorhanden sind,
		// der Pfad nur aus einem Schritt besteht und in einem Kontext steht, wo der
		// Textwert ausgewertet werden kann, so wird der Pfad als String-Literal interpretiert
		| {short_exact_search} l_quote pattern r_quote { -> New node_test.exact_search(pattern) }
		| {wild_search} text_wild lpar l_quote pattern r_quote rpar { -> New node_test.wild_search(pattern) }
		| {short_wild_search} l_wild_quote pattern r_quote { -> New node_test.wild_search(pattern) }
		| {regexp_search} text_regexp lpar l_quote pattern r_quote rpar { -> New node_test.regexp_search(pattern) }
		| {short_regexp_search} l_regexp_quote pattern r_quote { -> New node_test.regexp_search(pattern) }
		
		// Variablenreferenz
		| {varref} variable_binding { -> New node_test.varref(variable_binding.id) }
		;
		
	namespace { -> id } =
		  [namespace]:id colon { -> namespace }
		;
		
	// 7.4.6 Kontextauswahl und Treffermarkierungen
	marker_spec { -> marker_spec } = 
		  {simple} hash marker_name? { -> New marker_spec(marker_name.id) }
		| {start} hash_plus marker_name? { -> New marker_spec.start(marker_name.id) }
		| {end} hash_minus marker_name? { -> New marker_spec.end(marker_name.id) }
		;
		
	marker_name { -> id? } =
		  lpar id? rpar { -> id }
		;
		
	// 7.4.10 Boolsche Ausdrücke und Prädikate
	predicate { -> expr } = 
		  lbracket expr rbracket { -> expr }
		;
		
	// 7.4.7 Variablen / Joins
	variable_binding { -> id } =
		  dollar id { -> id }
		;
		
Abstract Syntax Tree

	expr =
		  {path} path_type step+
		| {or} expr+
		| {and} expr+
		| {comparison} comparison [lhs]:expr [rhs]:expr
		| {plus} [lhs]:expr [rhs]:expr
		| {minus} [lhs]:expr [rhs]:expr
		| {times} [lhs]:expr [rhs]:expr
		| {div} [lhs]:expr [rhs]:expr
		| {idiv} [lhs]:expr [rhs]:expr
		| {mod} [lhs]:expr [rhs]:expr
		| {number_literal} number
		| {string_literal} [string]:pattern
		| {regexp_literal} [regexp]:pattern
		| {function} [name]:id [args]:expr*
		;
		
	comparison = 
		  {eq}
		| {ne}
		| {lt}
		| {le}
		| {gt}
		| {ge}
		;
	
	path_type = 
		  {relative}
		| {absolute}
		;
		
	step =
		  axis? node_test marker_spec? [predicates]:expr* [variable]:id?
		;
		
	axis = 
		  {child} edge_type_spec? edge_annotation*
		| {left_child}
		| {right_child}
		| {parent} 
		| {descendant} edge_type_spec? range_spec?
		| {ancestor}
		| {sibling} edge_type_spec? edge_annotation*
		| {common_ancestor} edge_type_spec?
		| {following} range_spec?
		| {preceding}
		| {following_sibling}
		| {preceding_sibling}
		| {immediately_following_sibling}
		| {immediately_preceding_sibling}
		| {immediately_following}
		| {immediately_preceding}
		| {contained}
		| {containing}
		| {prefix}
		| {suffix}
		| {overlapping}
		| {overlapping_following}
		| {overlapping_preceding}
		| {whole_text}
		| {element_span}
		| {attribute}
		| {layer} [name]:id
		| {alignment} alignment_spec
		| {aligned} alignment_spec
		| {matching_element}
		| {containing_element}
		| {contained_element}
		| {left_align}
		| {right_align}
		;
		
	range_spec = 
		[min]:number [max]:number?
		;
		
	edge_annotation = 
	      {existance} [namespace]:id? [type]:id
		| {exact} [namespace]:id? [type]:id [value]:pattern
		| {regexp} [namespace]:id? [type]:id [value]:pattern
		;
		
	edge_type_spec = [edge_type]:id? [name]:id?;
	
	sibling_spec = [name]:id;
			
	alignment_spec = 
	    [role1]:id [role2]:id [greed1]:id? [greed2]:id?
		;
		
	node_test =
		  {element} [name]:id?
		| {attribute} [namespace]:id? [name]:id?
		| {span}
		| {unknown} [namespace]:id? [name]:id?
		| {exact_search} pattern
		| {wild_search} pattern
		| {regexp_search} pattern
		| {varref} [variable]:id
		| {meta} [namespace]:id? [name]:id [value]:quoted_text
		;
		
	marker_spec =
		  [marker]:id?
		| {start} [marker]:id?
		| {end} [marker]:id?
		;

	quoted_text = 
		  [string]:pattern
		| {regexp} [regexp]:pattern
		;