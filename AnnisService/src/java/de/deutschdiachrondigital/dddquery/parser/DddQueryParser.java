package de.deutschdiachrondigital.dddquery.parser;

import java.io.IOException;
import java.io.PushbackReader;
import java.io.StringReader;
import java.util.List;

import org.apache.log4j.Logger;

import de.deutschdiachrondigital.dddquery.analysis.DepthFirstAdapter;
import de.deutschdiachrondigital.dddquery.helper.TreeDumper;
import de.deutschdiachrondigital.dddquery.lexer.Lexer;
import de.deutschdiachrondigital.dddquery.lexer.LexerException;
import de.deutschdiachrondigital.dddquery.node.Start;

/**
 * A class that parses DDDquery strings.
 * 
 * <p>
 * This class parses a DDDquery string and returns a class representation of the parse tree.
 * The actual parser is automatically generated by SableCC from the parser definition file <tt>dddquery.grammar</tt>,
 * as are the classes that represent the parse tree.
 * 
 * <p>
 * To ease the writing of the parser definition file, the parse tree returned by the SableCC-generated parser
 * is incomplete and has to be modified to genuinely represent the given input string.  This is achieved supplying
 * this class a list of post processors (subclasses of {@link DepthFirstAdapter}) that are applied to the
 * SableCC-generated parser tree in the order they appear in the list.
 *  
 * <p>
 * Exception that are thrown by SableCC (ParserException, LexerException, IOException) are wrapped
 * in a soft ParseException.
 * 
 * @author Viktor Rosenfeld <rosenfel@informatik.hu-berlin.de>
 */
public class DddQueryParser {

	private Logger log = Logger.getLogger(this.getClass());
	
	private List<DepthFirstAdapter> postProcessors;

	// TODO exceptions
	public Start parseDddQuery(String input) {
		try {
			
			log.info("parsing DDDquery: " + input);
			
			Parser parser = new Parser(new Lexer(new PushbackReader(new StringReader(input))));
			Start start = parser.parse();
			
			for (DepthFirstAdapter postProcessor : postProcessors) {
				log.debug("applying post processor to parse tree: " + postProcessor.getClass().getSimpleName());
				start.apply(postProcessor);
			}
			
			log.info("done");
			log.debug("parse tree is:\n" + new TreeDumper().dumpTree(start));
			
			return start;
			
		} catch (ParserException e) {
			log.warn("an exception occured on the query: " + input, e);
			throw new ParseException(e);
		} catch (LexerException e) {
			log.warn("an exception occured on the query: " + input, e);
			throw new ParseException(e);
		} catch (IOException e) {
			log.warn("an exception occured on the query: " + input, e);
			throw new ParseException(e);
		}
	}
	
	public List<DepthFirstAdapter> getPostProcessors() {
		return postProcessors;
	}

	public void setPostProcessors(List<DepthFirstAdapter> postProcessors) {
		this.postProcessors = postProcessors;
	}
	
}
